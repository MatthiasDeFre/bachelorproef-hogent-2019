\chapter{Shortlist frameworks Augmented Reality}
\label{ch:shortlist}

In de shortlist wordt de gekozen technologie uit de longlist, namelijk augmented reality, verder besproken.
Eerst volgt er een uitleg over wat de uiteindelijke applicatie moet bevatten.
Hierna volgt er een oplijsting van de verschillende frameworks van augmented reality. Per framework is er uitleg over wat het framework exact is, welke algoritmen deze gebruikt en aan welke requirements deze al dan niet voldoet. Aan de hand van deze krijgt elk framework dan een score krijgen die invloed heeft of dit framework wordt opgenomen in het experiment of niet.

\section{Uitleg Applicatie}
Voor deze studie is er gekozen om een applicatie te ontwikkelen die features combineert van soortgelijke use cases. De applicatie beschikt over de mogelijkheid om kunstwerken in te scannen en hierop digitale objecten te tonen. Ook is er een menu beschikbaar waar de gebruiker kan kiezen om een levensverhaal beginnen te volgen. In dit menu is er ook een optie om de ontdekte kunstwerken van een levensverhaal te bekijken op een tijdlijn die zo het leven voorstelt.

Om er voor te zorgen dat gebruikers niet te veel gebonden zijn aan de chronologie van het levensverhaal kunnen ze er ook voor kiezen om zonder rondleiding rond te lopen in het museum en op deze manier de kunstwerken te scannen.

Als extra moet er ook de mogelijkheid zijn om de virtuele objecten in de wereld te kunnen plaatsen, zonder het bijbehorend kunstwerk, door middel van plane detectie.

\section{Requirements}
Om de requirements van een applicatie op te schrijven zijn er verscheidene technieken. Voor deze use case worden de standaarden gebruikt van \textcite{Bradner1997}. Hierbij zijn er vijf verschillende soorten levels namelijk: MUST, MUST NOT, SHOULD, SHOULD NOT en MAY. Uit de bovenstaande uitleg over de applicatie en de uitleg in verband met teleprescence kunnen we volgende vereisten uithalen alsook nog optionele nice-to-haves toevoegen. Deze vereisten kunnen een positieve of negatieve invloed hebben op de score van het framework, de maximum score die een framework kan halen is 31.

\subsection{MUST}
Deze vereisten moet het framework sowieso ondersteunen en zullen dus veel harder doorwegen op de uiteindelijke score van het framework per MUST voorwaarde die voldaan is wordt de score met 5 verhoogt terwijl het ontbreken van een voorwaarde een negatieve invloed heeft van -5.
\begin{itemize}
    \item Ondersteuning van image herkenning
    \item Draaien op een groot aantal verschillende devices
    \item Klikken op het scherm linken aan een actie
    \item Tonen van informatie over het kunstwerk
    \item Ondersteunen verschillende 3d object formaten
\end{itemize} 

\subsection{MUST NOT}
Indien één van deze vereisten voorkomt bij het framework komt het framework niet meer in aanmerking komen om opgenomen te worden in het experiment.
\begin{itemize}
    \item Verplicht gebruik van specifieke hardware (bv. sensoren, depth camera)
    \item Verplicht gebruik van de meest recente versies van software
\end{itemize} 

\subsection{SHOULD}
De SHOULD of RECOMMENDED vereisten zijn diegene waarbij het aangeraden is dat het framework ze ondersteund maar zijn niet verplicht voor een uiterst basisimplementatie van de applicatie. Het hebben van deze vereisten verhoogt de score per vereiste met 3 maar heeft geen negatieve invloed  indien deze toch ontbreken.
\begin{itemize}
    \item Ondersteuning van plane detectie en het plaatsen van virtuele objecten hierop
    \item Ondersteuning van object herkenning
    \item Goede development documentatie
    \item Offline beschikbaar zijn
\end{itemize} 

\subsection{SHOULD NOT}
De opgelijste vereisten van deze categorie komen liefst niet voor in een framework maar het is niet zo erg indien ze toch zouden voorkomen zolang het framework genoeg andere MUST en SHOULD vereisten heeft. Het is hierdoor dat dit maar een kleine negatieve invloed heeft van -3.
\begin{itemize}
    \item Hevige drifting
\end{itemize} 

\subsection{MAY}
Deze vereisten zijn volledig optioneel en zullen niet zoveel invloed hebben op de score maar kunnen de ervaring van de gebruiker wel positief beïnvloeden. Omdat deze requirements optioneel zijn hebben ze alleen maar een kleine positieve invloed op de score van +1.
\begin{itemize}
    \item Light estimation (aanpassen virtuele wereld indien licht in de echte wereld verandert)
    \item Ondersteuning van browser
     \item Virtuele buttons
     \item Images blijven tracken als ze bewegen
\end{itemize} 

\section{8th Wall}
Alhoewel ze zich de laatste tijd meer en meer hebben gefocust op 8th Wall Web heeft dit framework ook nog een tweede luik met 8th Wall XR. Het verschil tussen deze twee subframeworks is dat Web, zoals de naam het al duidelijk maakt, in een web browser draait. Echter zijn wel niet alle browsers ondersteund voor iOS is alleen Safari ondersteunt terwijl voor Android: Chrome, Chome varianten en Firefox ondersteund zijn \autocite{8thWallWebReq}.

% TODO MOVE CONTENT
De instapdrempel voor ontwikkeling ligt hierbij wel redelijk laag omdat vele developers toch al wat ervaring hebben met javascript en html.

\subsection{8th Wall XR}
Met dit onderdeel van 8th Wall kunnen native augmented reality applicaties ontwikkelt worden voor Android en ioS. Dit maakt gebruik van



\section{ARCore}
Het native AR framework voor Android, ontwikkelt door Google. Alhoewel dit framework speciaal gemaakt is voor Android biedt deze ook de mogelijkheid om apps te ontwikkelen voor iOS en zelfs voor een webbrowser \autocite{ARCoreOverview}. Omdat de webbrowser versie van ARCore alleen draait op Canary (de developer variant van Chrome) en ook hier nog eventjes zal blijven wordt deze niet verder besproken \autocite{ARCoreWeb}.

Voor het ontwikkelen van een applicatie met ARCore zijn er verschillende mogelijkheden. Er kan gekozen worden om puur native te gaan en gebruik te maken van de iOS of Android SDK ook is er de optie om Unity of Unreal engine te gebruiken. Het voordeel hieraan is dat er veel keuze is in welke taal er geprogrammeerd kan worden. Wordt er Unreal of Unity gebruikt dan kunnen de ontwikkelde applicaties makkelijk worden omgezet om op iOS en Android te kunnen draaien. 

\subsection{Light Estimation}
ARCore heeft de mogelijkheid om variatie in licht te herkennen en hierdoor de lichtinval op de virtuele objecten aan te passen om zo meer het gevoel te geven dat ze daadwerkelijk in de wereld staan. Dit verhoogt dan weer het niveau van teleprescence \autocite{ARCoreConcepts}.

Niet alleen de lichtinval van de objecten kan worden aangepast, de virtuele objecten kunnen ook reageren op veranderingen in lichtniveau.
\subsection{Cloud Anchors}
Met de opkomst van zoveel mogelijk software over te schakelen naar de cloud was het ook logisch dat augmented reality uiteindelijk ging volgen. Aan de hand van cloud anchors kan een ankerpunt in een ruimte worden gedeeld met andere gebruikers. 

Om een cloud anchor aan te maken moet de gewenste ruimte eerst gemapped zijn en hierin een ankerpunt zijn gecreëerd. De applicatie zal dan de relatieve positie van dit punt naar verhouding van nabijgelegen feature points versturen naar de Google servers die deze data dan zal hosten. 

Het hosten van deze data gebeurt door een Firebase databank die aan elk punt een id geeft, eens een ankerpunt gehost is zal de server een roomcode terugsturen waarmee andere gebruikers het anker kunnen zien. Omdat een kamer soms meerdere ankerpunten heeft kan het ook soms zijn dat er meerdere punten aan één roomcode worden gelinkt \autocite{ARCoreCloudAnchors}.
% TODO IMAGE LIGHT ESTIMATION
% TODO TRANSLATE relative => De relatieve positie van dit punt naar verhouding van... ? ASK!
\subsection{Requirements}
\section{ARKit}
ARKit is de native technologie voor iOS in tegenstelling tot ARCore kan men met die framework alleen iOS applicaties ontwikkelen.

De ontwikkeling van ARKit applicaties kan gebeuren via XCode (de IDE van Apple), Unity of Unreal. XCode zal gebruik maken van Swift of Objective C terwijl Unity en Unreal hun taal gebruiken (C\# en C++ respectievelijk).
% TODO CONTENT Extra info

\subsection{Persistent Mapping}
Sinds ARKit 2.0 is er de mogelijkheid om persistent mapping in ARKit applicaties te implementeren. Met dit kan een gemapte ruimte worden opgeslagen zodat de mapping tussen sessies opgeslagen blijft.
Om bij een volgende sessie de mapping op te halen moet de camera van de smartphone terug worden geplaatst naar de locatie waar de mapping was opgeslagen. Eens deze volledig geladen is kunnen ook de ankerpunten worden teruggezet met hun virtuele objecten \autocite{ARKitPersistent}.

\subsection{Multiuser Experience}
Dit is een uitbreiding van persistent mapping waarbij mapping data tussen apparaten kan worden gedeeld. Het eerste apparaat moet de ruimte scannen en kan deze data dan doorsturen naar andere apparaten. Wanneer een virtueel object wordt geplaatst in de ruimte zal deze worden getoond bij alle apparaten.

Om de communicatie tussen de devices te regelen wordt er gebruikgemaakt van peer-to-peer networking. Dit betekent dat, in tegenstelling met ARCore, er geen server nodig is om ankerpunten te delen. Een belangrijk iets om rekening mee te houden is dat standaard de applicatie zich met de eerst gevonden sessie zal verbinden. Indien dit niet correct geconfigureerd is kan dit wel voor problemen zorgen in plaatsen waar er veel sessies tegelijk zouden zijn zoals in musea.

Alhoewel er geen server nodig is kan het soms wel handig zijn dat een apparaat als server handelt, indien dit gewenst is kan dit worden ingesteld.

Nog een groot verschil met ARCore is dat bij ARCore alleen de locatie en feature points van de ankerpunten worden teruggestuurd terwijl bij ARKit de hele mapping data verstuurt. Het versturen van deze data kan heel wat bandbreedte opnemen dus indien er veel apparaten zijn die met dezelfde sessie willen verbinden kunnen er problemen optreden \autocite{ARKitMultiuser}.

\subsection{Requirements}


\section{Vuforia}
Net zoals 8th Wall biedt Vuforia de mogelijkheid om native applicaties te ontwikkelen voor Android en iOS. Vele andere frameworks ondersteunen ook het herkennen van images en sommige zelfs objecten maar geen enkel ander framework focust zich hier evenveel op als Vuforia.  

Ontwikkeling van Vuforia applicaties kan gebeuren in de native development omgevingen van Android, iOS, UWP door gebruik te maken van passende SDK. Ook is er de mogelijkheid om applicaties te ontwikkelen in Unity, deze kunnen dan draaien op alle bovenstaande native technologieën.

\subsection{Fusion}
Het unieke aan Vuforia is de manier waarop deze \acrshort{slam} implementeert. Vuforia zal zoveel mogelijk proberen gebruik te maken van de native mapping algoritmen (ARKit, ARCore en MR). Hierdoor kan deze gebruikmaken van alle features die deze native technologieën bevatten alsook nog zijn eigen functionaliteiten hieraan toevoegen. Op deze manier ondersteunt Vuforia direct alle ondersteunde apparaten van ARKit, ARCore en MR. Voor apparaten die niet ondersteunt zijn door deze frameworks is er VISLAM en \acrshort{slam}. Hierdoor is er ook ondersteuning voor oudere apparaten die niet ARKit of ARCore ondersteunen \autocite{VuforiaFusion}.
\begin{figure}
    \includegraphics[width=\linewidth]{vuforiaFusion.png}
    \caption{Vuforia Fusion}
    \label{fig:vuforiaFusion}
\end{figure}

\subsection{Cloud Recognition}
Om afbeeldingen te herkennen is er een image target database nodig. Omdat deze database soms redelijk groot kan worden bij applicaties die veel afbeeldingen bevatten is het aangeraden om hierbij gebruik te maken van een online database om een goede performance te garanderen \autocite{VuforiaCloudReco}. 

Er is ook de mogelijkheid om metadata te linken aan de images in de databank. Hierdoor kan de applicatie weten wat hij exact moet tonen in de virtuele wereld. Het is mogelijk om verschillende soorten data hieraan te linken waaronder: JSON, URLS of zelfs een volledig 3d object (zolang deze onder de geheugengrootte zit van 2MB) \autocite{VuforiaCloudReco}.



\subsection{Targets}
Vuforia bied vijf soorten herkenning aan, deze worden hieronder kort uitgelegd wat ze exact doen en hoe ze werken.

\begin{itemize}
    \item Image Targets: gewone afbeeldingen
    \item Model Targets: het herkennen van 3d objecten en deze veranderen in een virtueel object
    \item Multi Targets: meerdere afbeeldingen herkennen en deze samenvoegen
    \item VuMarks: soort van custom QR Codes zie figuur \ref{fig:vumarks}
    \item Cylinder Targets: afbeelding herkennen op een cylinder vorm
\end{itemize} 

\begin{figure}
    \includegraphics[width=\linewidth]{vumarks.png}
    \caption{Voorbeeld VuMark}
    \label{fig:vumarks}
\end{figure}
\subsection{Requirements} 

\section{Conclusie}
% TODO TABLE